### 힙/스택

컴파일 시점에 변수의 타입을 예상하기 어렵기 때문에

데이터는 힙에 보관하고, 변수에는 해당 데이터의 힙에서의 주소를 보관해야 한다.

스택에서 필요한 크기를 미리 계산해야 하는지?

* 가령 함수 내의 지역 변수 개수를 미리 세서 고정된 크기만큼 스택 포인터를 움직여 놓을 수 있다. 이 경우에는 움직여진 스택의 top으로부터 변수의 offset만큼 빼기 연산을 통해 변수의 저장공간을 나타낼 수 있음.
* 반대로 계산을 미리 하지 않은 경우에는 스택 포인터를 가만히 두고 더하기 연산을 통해 변수를 이용할 수 있음.
* 그러나 생각해보니 스택에 push되는 건 지역 변수 뿐만이 아니라, 표현식의 결과값 등이 push될 수 있음.

결론: 지역변수를 offset으로 접근하기 위해서는 미리 개수를 세서 고정 크기를 구해야 한다.

이외에도 스택에 미리 할당해야 할 것들이 있을지 생각해봐야 한다.

* Return 주소

물론 위 내용은 동적 타입 언어를 개발할 때의 고려 사항이다.

---

### 클로저

```python
def f():
    a  = 1
    def g():
        return a
    return g
```

g 함수에서 변수를 어떻게 캡쳐해야 할까?

위의 예시에만 한정하여 생각해보면, 단순히 상위 scope에 나타난 a가 가리키는 address를 g 내부의 a 변수에 복사하여 저장하면 된다.

문제는 다음과 같은 경우다.

```python
def f():
	a = 1
	def g():
		a = a + 1
	return g
```

g함수에서 a가 가리키는 객체를 변경한다.

이 경우에는 사실상 g 내부의 a를 이중 포인터로 간주하여 처리해야 한다.

그래서 실제 파이썬에서는 어떻게 처리되나 찾아봤는데, Cell 객체를 이용한다고 한다고 함.

즉 변수를 캡쳐하게 되면 Cell 객체를 생성하여 해당 객체에 대한 레퍼런스를 참조하도록 하고,

값에 액세스할 때는 Cell 객체가 가리키는 변수가 가리키는 데이터가 얻어지도록 처리한다고 한다.

### 결론

파이썬의 Cell 객체(이중포인터)와 같은 것을 생성하고 처리할 수 있도록 바이트코드를 새로 정의하자.

---

### JIT 컴파일

어떻게 구현할 것인지?

간단하게 생각해보면, 코드를 필요할 때 컴파일하고, 그에 따라 생성된 바이너리 프로그램을 실행하면 된다.

컴파일 된 결과는 힙에 저장한다.

사실상 함수가 컴파일될 때 동일한 일이 벌어지는 것이 아닌지?

재사용 가능한 코드를 어떻게 컴파일할지를 생각해보고 그에 따라 도출된 방법을 일관성 있게 적용하면 될 것 같다.

---

### 객체

가령 클래스는 일종의 연관 배열으로 간주해야 할까?

구조체는 더이상 필드가 변경되지 않으므로, 컴파일 시점에 필드명을 순차적인 인덱스로 변환할 수 있다. (물론 각 필드의 크기를 고려해야 함)

하지만 루아의 테이블과 같은 자료구조의 경우 런타임에 필드가 추가/삭제될 수 있다. (파이썬의 클래스도 그런 것 같은데 정확히 찾아보지는 않음) 이는 연관 배열(=맵, 혹은 사전)으로 구현해야 한다.

또한 동적 타입 언어의 경우 데이터와 함께 여러 메타 데이터를 저장해야 한다.



---

### 정적 타입

정적 타입 언어를 개발하려면 어떤 것들을 고려해야 할까

가령 구조체와 같은 자료구조를 생성할 수 있도록 해야 한다.

Call by reference, Call by value 등을 고려해야 한다.

가령 모든 객체를 힙에 생성하고 변수는 포인터로서만 작동할 수 있다.
