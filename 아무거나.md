## 이벤트 시스템

### 참고자료 

* 유튜브
  * https://youtu.be/DY3sUeGu74M?si=ZWPesMYS90K--vI5


### Event의 요소를 잘 정의해야 한다.

* 대상
* 행동
* 정보
* 시간

### 주의점

* 행위자 기반의 데이터 정의 필요
  * 소비자 비즈니스 로직과의 결합도가 높아지는 것을 방지해야 함.
* 이벤트의 순서가 중요
  * 순서를 보장할 방법이 필요하다.

### 이벤트 파이프라인

* 이벤트를 발행하려면 메시지 브로커를 선택해야 한다.

  * `카프카`를 선택한 이유
    * https://hudi.blog/what-is-kafka/
    * 순서 보장
      * 토픽의 파티션을 통해 Key별로 순서 보장
    * 고성능, 고가용성
      * 실시간 이벤트 처리를 위해 필요
      * 파티션 증설을 통한 처리량 증대
      * 메시지 배치 발행
      * 페이지 캐시
      * 브로커를 클러스터로 관리
        * 한 개의 브로커에 이슈가 생겨도 다른 브로커가 처리
        * 고가용성 보장
    * 통합 도구
      * Kafka Streams
      * Kafka Connect

* 하지만 문제가 있었다.

  * 가령, 네트워크 이슈 등의 이유로 도메인 상태와 이벤트 발행 결과가 불일치하는 문제가 발생
    * 이는 시스템 장애로 확산됨

*  `Transactional outbox Pattern`의 도입으로 해결

  * 참고자료
    * https://velog.io/@eastperson/Transaction-Outbox-Pattern-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0

  * 이벤트 기반 아키텍쳐에서 사용하는 패턴 중 하나
  * Database 시스템의 Transaction을 활용하여 Event를 Outbox Table에 적재하고
  * 이후에 Message Relay가 이벤트 발행을 보장하는 기법

* Message Relay로 `debezium`을 사용

  * DB의 변경사항을 감지하여 타 시스템에 전송해주는 오픈소스 플랫폼
  * Binary log를 통한 순서 보장 및 offset을 활용한 (실패 시 재시도) 발행 보장
  * Outbox 테이블 파티셔닝을 통한 처리량 증대
    * MySQL 특성상 이벤트를 직접 적절한 Outbox 테이블의 파티션에 적재할 필요가 있었음.
    * 이후 각 debezium 객체가 각각의 파티션을 처리

### 이벤트의 활용 사례

* 순서가 보장된 이벤트는 이벤트 스트림을 구성한다.
  * 이벤트 스트림으로 CQRS를 적용
    * https://mslim8803.tistory.com/73
  * 카프카에 쌓이는 이벤트 스트림을 S3 Sink Connector를 이용하여 AWS S3에 저장
    * AWS에서 제공하는 Glue, Athena를 활용하여 데이터 분석 환경 구축
    * Apache Airflow를 통해 전사 Datelake에 연결
  * 이벤트 스트림으로 스트림즈 애플리케이션 구현
    * Kafka Streams를 활용
    * 실시간 데이터 제공 및 모니터링

### 궁금증

* 가령 소비자가 어떤 이벤트를 소비하게 되면 다른 소비자들은 소비를 할 수 없게 되는 것인지?
  * 애초에 그 점이 고려되어 메시지 큐에 넣어지는 게 아닐까 싶기도 하다.
  * 여러 소비자가 있을 수 있다면 메시지 큐에 여러 개를 복제해서 넣거나, 또는 복수의 메시지 큐에 전달
  * 여튼 검색 필요

