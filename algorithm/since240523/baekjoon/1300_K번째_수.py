def find(s, e):
    if s >= e:
        return s
    mid = (s + e) // 2
    cnt = 0
    for i in range(1, n + 1):
        cnt += min(n, mid // i)
    if cnt >= k:
        return find(s, mid)
    else:
        return find(mid + 1, e)

n = int(input())
k = int(input())


print(find(1, k))


'''
시작 시간: 19:56
종료 시간: 실패

접근:
    n은 10만까지, k는 10억까지


    B[k]가 될 수 있는 값의 범위는?

    x = 1 부터 100억

    k가 주어졌을 때 B[k] == x인지 검증이 가능할지?

        B[k] == x인지 확인하는 방법을 찾아보자.

        x는 i * j이므로 2개의 숫자로 인수분해가 되어야 함.

        또한 i, j 는 k 이상이 될 수 없음.
        
    
    a[i][i]는 i * i번째 수이다.

    가령 a[2][2] = 4 는 4번째 수
    a[3][3] = 9 는 9번째 수


    7번째 수는?

    4와 9 사이에 존재함.

    10억 번째 수는?

    1억과 100억 사이의 값임.

    그럼 50억보다는 클지?




후기:

    못 풀고 풀이를 확인 함.

    B[k]를 x라고 했을 때, x보다 같거나 작은 수가 몇개인지를 세야 한다.

    이는 A배열의 각 행 또는 열의 index로 x를 나눈 몫을 더해주면 된다.

    1행에서는 x / 1 = 50개,
    2행에서는 x / 2 = 25개,
    3행에서는 x / 3 = ...개

    이를 모두 더해주면 배열에서의 x보다 작거나 같은 수의 개수를 얻을 수 있다.

    다만 개수가 k와 항상 일치하는 것은 아니다.

    결국 개수가 나열되어 있을 때 k가 들어갈 위치를 이분탐색으로 찾는 꼴이 된다.


'''