import sys
input = sys.stdin.readline

def find(s, e):
    if s >= e:
        return s
    mid = (s + e + 1) // 2
    cnt = 1
    pre = 0
    for i in range(1, n):
        if x[i] - x[pre] >= mid:
            cnt += 1
            pre = i
    if cnt >= c:
        return find(mid, e)
    else:
        return find(s, mid - 1)



n, c = map(int, input().split())
x = [int(input()) for _ in range(n)]
x.sort() # 1 2 4 8 9

print(find(0, 1000000000))


'''
시작 시간: 19:33
종료 시간: 19:53

접근:
    그리디하게 풀 수 있어 보인다.

    공유기를 최적으로 배치 했을 때

    가령 한쪽 끝의 집이 비어있다면, 가장 근처의 공유기를 끝으로 옮겨도 최적의 상태가 유지된다.

    따라서 먼저 양 끝에 공유기를 하나씩 설치하고 시작

    -> 하지만 일반화된 풀이가 도출되지 않음


    거리를 1,000,000,000부터 감소시킨다면?

    -> 이분탐색으로 풀이 가능

    거리를 d라고 하자.

    집을 하나씩 순회하며, 양쪽 집과의 거리가 d 이상인 경우에만 cnt를 증가시킨다.

    cnt가 n 이상이면, d를 더 증가시키고 반복
        right를 탐색할 때 mid가 포함되므로 mid = (s + e + 1) // 2

    cnt가 n 미만이면 d를 감소시키고 반복

    
    또한 첫번째 논리에 의해 무조건 첫 집에 꽂고 시작하면 된다.


후기:
    맨 처음의 집에 공유기가 설치되어 있어야 한다는 것은 금방 생각해냈으나
    이분 탐색을 이용할 방법을 빠르게 생각해내지 못했다.

    앞으로 이분 탐색 문제를 풀 때는
    구해야 하는 값의 [min, max] 구간을 조건을 만족하는 구간과 그렇지 않은 구간 2가지로 나뉘어 질 수 있는지를
    먼저 확인해봐야 한다.

'''